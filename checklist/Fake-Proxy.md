# Fake Proxy

---

When Dealing with proxy we should always be careful as it doen't always safe. There is some standard proxy pattern in like [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967) there will be delegatecall to implementation contract when we call a specific function from proxy contract. And implementation contract address stored at specific storage slot (`_IMPLEMENTATION_SLOT`). This `_IMPLEMENTATION_SLOT` can manipulated and contract doesn't behave as it should.

### Example

[This](https://goerli.etherscan.io/address/0x7d6dfe664bb6b93c9c1294bcac63dee0d3523a3e#readProxyContract) is one proxy contract which delegate call to address `0xc207089E73E4631bE612Cc853071D6AEEC2a40a1` as per etherscan.

But in actual case, proxy contract delgatecall to defferent address by reading different storage slot.
here : https://goerli.etherscan.io/address/0x425416b3bfaeedfa241613ee677005f9a8415ee8#code#F1#L655

```solidity
function _getImplementation() internal view returns (address) {
        return
            StorageSlot
                .getAddressSlot(bytes32(uint256(keccak256("eip1967.fake")) - 1))
                .value;
    }
```

when you read `check` value in proxy contract it should reaturn 1. but it return 0 as it read from deferent contract.

```solidity
  function check() external view returns (uint256) {
        return 1;
    }
```

https://goerli.etherscan.io/address/0xc207089e73e4631be612cc853071d6aeec2a40a1#code#F1#L66

so you should not always rely on etherscan also.
