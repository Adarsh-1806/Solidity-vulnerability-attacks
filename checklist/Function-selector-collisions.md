# Function Selector collision

If two functions have exact same signature in within your contract, the program will not run as during function call, the flow would be confused in which function it has to go. Function overloading is possible but the signature of each function should be unique within the contract. Different contracts can have same function signature.

If Proxy contract and implementation contract both has same function selector then proxy contract will have high priority.

### Example

Here There is one `Vault` contract which has proxy contract. Here `vaultManger(address)` from `Vault` contract and `IMGURL()` from proxy contract has same function signature `0xbab82c22`. so when we call `vaultManager(address)` from proxy contract it will always return `true` without checking vaultMangers mapping as it directly call `IMGURL()` function within proxy contract.

##### Vault.sol

```solidity
contract Vault is Initializable {

    mapping (address->bool) public vaultManagers;

    constructor() {
        init(msg.sender);
    }

    function init (address manager) initializer public {
        vaultManagers [manager]= true;
    }

    function addManager (address m) external {
        require(vaultManagers [msg.sender]);
        vaultManagers [m] = true;
    }

    function removeManager (address m) external {
        require(vault Managers [msg.sender]);
        vault Managers[m] = false;
    }
}
```

##### ERC1967Proxy.sol

```solidity
    contract ERC1967Proxy is Proxy, ERC1967Upgrade {
    /**
    * @dev Initializes the upgradeable proxy with an initial implementation specified by logic.
    *
    * If data is nonempty, it's used as data in a delegate call to logic. This will typically be an encoded
    * function call, and allows initializating the storage of the proxy like a Solidity constructor.
    */
    constructor (address logic, bytes memory data) payable {
    assert( IMPLEMENTATION SLOT == bytes32 (uint256 (keccak256 ("eip1967.proxy.implementation")) 1));
    upgradeToAndCall(_logic, data, false);
    }

    /**
    * @dev Returns the current implementation address.
    */
    function implementation() internal view virtual override returns (address impl) {
        return ERC1967Upgrade. getImplementation();
    }
    function IMGURL() public pure returns (bool) {
        return true;
    }
}
```

### Referance

https://youtu.be/QhY9T-6QMlU?t=11591
